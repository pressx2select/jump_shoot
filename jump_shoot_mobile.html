<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Jump Shoot</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #222;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Press Start 2P', cursive;
            color: #eee;
            user-select: none; /* Prevent text selection */
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none; /* IE10+ */
        }

        #game-container {
            background-color: #333;
            border: 5px solid #555;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5), 0 0 60px rgba(255, 0, 255, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px; /* Reduced padding for mobile */
            max-width: 98vw; /* Allow it to take up more width on small screens */
            width: 100%; /* Ensure it takes full width within its flex context */
            box-sizing: border-box;
            display: none; /* Hidden by default */
        }

        canvas {
            background-color: #000;
            display: block;
            border: 2px solid #555;
            border-radius: 8px;
            width: 100%; /* Make canvas responsive */
            max-width: 800px; /* Reduced max width for better mobile fit, original was 1000px */
            height: auto; /* Maintain aspect ratio */
            aspect-ratio: 3 / 4; /* Taller canvas */
            margin-bottom: 15px; /* Reduced margin for mobile */
        }

        #game-controls {
            display: flex;
            justify-content: center;
            gap: 10px; /* Reduced gap for mobile */
            flex-wrap: wrap; /* Wrap buttons on small screens */
            width: 100%;
            margin-top: 10px; /* Add a bit of top margin */
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px; /* Reduced gap */
            flex: 1; /* Allow groups to take equal space */
            min-width: 120px; /* Ensure groups don't shrink too much */
        }

        .player-label {
            font-size: 0.7em; /* Smaller font for labels */
            color: #ccc;
            margin-bottom: 3px; /* Reduced margin */
            text-align: center;
        }

        .game-button {
            background-color: #007bff;
            color: white;
            padding: 12px 20px; /* Reduced padding for mobile */
            border: none;
            border-radius: 8px; /* Slightly smaller border-radius */
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8em; /* Smaller font for buttons */
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0 0.2s ease;
            box-shadow: 0 4px 0 #0056b3; /* Smaller shadow */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            width: 100%; /* Make buttons take full width of their group */
            box-sizing: border-box; /* Include padding/border in width */
        }

        .game-button:hover {
            background-color: #0056b3;
            transform: translateY(-1px); /* Smaller transform */
            box-shadow: 0 5px 0 #004085; /* Smaller shadow */
        }

        .game-button:active {
            background-color: #004085;
            transform: translateY(2px); /* Smaller transform */
            box-shadow: 0 1px 0 #002c5f; /* Smaller shadow */
        }

        /* Specific button colors (kept original) */
        .game-button.jump {
            background-color: #28a745;
            box-shadow: 0 4px 0 #1e7e34;
        }
        .game-button.jump:hover {
            background-color: #1e7e34;
            box-shadow: 0 5px 0 #155d28;
        }
        .game-button.jump:active {
            background-color: #155d28;
            box-shadow: 0 1px 0 #0f3d1b;
        }

        .game-button.fireball {
            background-color: #dc3545;
            box-shadow: 0 4px 0 #bd2130;
        }
        .game-button.fireball:hover {
            background-color: #bd2130;
            box-shadow: 0 5px 0 #8d1924;
        }
        .game-button.fireball:active {
            background-color: #8d1924;
            box-shadow: 0 1px 0 #6e131b;
        }

        #message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            border: 4px solid #00ffff;
            border-radius: 15px;
            padding: 25px 35px; /* Reduced padding */
            text-align: center;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.7); /* Smaller shadow */
            z-index: 100;
            display: none;
            flex-direction: column;
            gap: 15px; /* Reduced gap */
            font-size: 1em; /* Smaller font */
            max-width: 90vw; /* Responsive width */
            box-sizing: border-box;
        }

        #message-text {
            color: #fff;
        }

        #restart-button {
            background-color: #ffc107;
            color: #333;
            padding: 10px 20px; /* Reduced padding */
            border: none;
            border-radius: 8px;
            font-family: 'Press Start 2P', cursive;
            font-size: 0.8em; /* Smaller font */
            cursor: pointer;
            box-shadow: 0 3px 0 #d39e00; /* Smaller shadow */
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
            display: none;
        }

        #restart-button:hover {
            background-color: #e0a800;
            transform: translateY(-1px);
            box-shadow: 0 4px 0 #b38700;
        }

        #restart-button:active {
            background-color: #c69500;
            transform: translateY(1px);
            box-shadow: 0 1px 0 #9f7d00;
        }

        /* Score display and bar positions are handled in JS to be relative to canvas */
        /* These CSS rules are for the labels if they were separate HTML elements, but they are drawn on canvas. */

        /* Styles for the new menu screen */
        #menu-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            border: 4px solid #00ffff;
            border-radius: 15px;
            padding: 40px 50px; /* Reduced padding */
            text-align: center;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.7); /* Smaller shadow */
            z-index: 200;
            display: flex;
            flex-direction: column;
            gap: 20px; /* Reduced gap */
            max-width: 90vw; /* Responsive width */
            box-sizing: border-box;
        }

        #menu-title {
            font-size: 2.5em; /* Smaller font */
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.9); /* Smaller shadow */
            margin-bottom: 15px; /* Reduced margin */
        }

        .menu-button {
            background-color: #007bff;
            color: white;
            padding: 15px 30px; /* Reduced padding */
            border: none;
            border-radius: 10px;
            font-family: 'Press Start 2P', cursive;
            font-size: 1.2em; /* Smaller font */
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0 0.2s ease;
            box-shadow: 0 5px 0 #0056b3; /* Smaller shadow */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            width: 100%;
            max-width: 250px; /* Smaller max width */
            margin: 0 auto;
        }

        .menu-button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
            box-shadow: 0 7px 0 #004085;
        }

        .menu-button:active {
            background-color: #004085;
            transform: translateY(1px);
            box-shadow: 0 2px 0 #002c5f;
        }

        /* Styles for the new character selection screen */
        #character-select-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            border: 4px solid #00ffff;
            border-radius: 15px;
            padding: 40px 50px; /* Reduced padding */
            text-align: center;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.7); /* Smaller shadow */
            z-index: 200;
            display: none;
            flex-direction: column;
            gap: 20px; /* Reduced gap */
            max-width: 90vw; /* Responsive width */
            box-sizing: border-box;
        }

        #character-select-title {
            font-size: 2em; /* Smaller font */
            color: #00ffff;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.7); /* Smaller shadow */
            margin-bottom: 10px; /* Reduced margin */
        }

        .character-option {
            background-color: #444;
            color: white;
            padding: 15px; /* Reduced padding */
            border: 3px solid #777;
            border-radius: 10px;
            font-family: 'Press Start 2P', cursive;
            font-size: 1em; /* Smaller font */
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0 0.2s ease, border-color 0.2s ease;
            box-shadow: 0 4px 0 #333; /* Smaller shadow */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            margin-bottom: 10px; /* Reduced margin */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px; /* Reduced gap */
            min-width: 200px; /* Smaller min width */
        }

        .character-option:hover {
            background-color: #555;
            transform: translateY(-1px);
            box-shadow: 0 5px 0 #222;
            border-color: #00ffff;
        }

        .character-option:active {
            background-color: #333;
            transform: translateY(2px);
            box-shadow: 0 1px 0 #111;
        }

        .character-description {
            font-size: 0.6em; /* Smaller font */
            color: #ccc;
            margin-top: 3px; /* Reduced margin */
        }

        /* Mobile-specific adjustments (media queries) */
        @media (max-width: 768px) {
            #game-container {
                padding: 10px; /* Even less padding on smaller screens */
            }

            canvas {
                margin-bottom: 10px; /* Even less margin */
            }

            #game-controls {
                flex-direction: column; /* Stack controls vertically */
                gap: 10px;
            }

            .control-group {
                flex-direction: row; /* Keep buttons in a row within their group */
                justify-content: space-around;
                width: 100%;
                gap: 5px; /* Smaller gap between buttons in a group */
            }

            .game-button {
                padding: 10px 15px; /* Further reduced padding */
                font-size: 0.7em; /* Even smaller font */
                min-width: unset; /* Allow buttons to shrink further */
                flex: 1; /* Distribute space evenly */
                margin: 0 2px; /* Minimal horizontal margin */
            }

            .player-label {
                display: none; /* Hide player labels on small screens to save space */
            }

            #message-box {
                padding: 15px 25px;
                font-size: 0.9em;
                gap: 10px;
            }

            #restart-button {
                padding: 8px 15px;
                font-size: 0.7em;
            }

            #menu-screen, #character-select-screen {
                padding: 25px 35px;
                gap: 15px;
            }

            #menu-title {
                font-size: 1.8em;
            }

            #character-select-title {
                font-size: 1.5em;
            }

            .menu-button, .character-option {
                padding: 12px 25px;
                font-size: 1em;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="750" height="1000"></canvas>
        <div id="game-controls">
            <div class="control-group">
                <span class="player-label">Player 1 (A/S)</span>
                <button id="player1JumpBtn" class="game-button jump">JUMP</button>
                <button id="player1FireBtn" class="game-button fireball">FIREBALL</button>
            </div>
            <div class="control-group" id="player2-controls">
                <span class="player-label">Player 2 (K/L)</span>
                <button id="player2JumpBtn" class="game-button jump">JUMP</button>
                <button id="player2FireBtn" class="game-button fireball">FIREBALL</button>
            </div>
        </div>
    </div>

    <div id="message-box">
        <span id="message-text"></span>
        <button id="restart-button">RESTART</button>
    </div>

    <div id="menu-screen">
        <h1 id="menu-title">JUMP_SHOOT</h1>
        <button id="onePlayerBtn" class="menu-button">1 PLAYER</button>
        <button id="twoPlayerBtn" class="menu-button">2 PLAYERS</button>
    </div>

    <div id="character-select-screen">
        <h1 id="character-select-title">SELECT YOUR CHARACTER</h1>
        <button id="charStandardBtn" class="character-option">
            Standard Character
            <span class="character-description">Basic fireball, reliable.</span>
        </button>
        <button id="charBouncingBtn" class="character-option">
            Bouncing Character
            <span class="character-description">Fireball bounces off the ground.</span>
        </button>
        <button id="charCurvingBtn" class="character-option">
            Curving Character
            <span class="character-description">Fireball curves based on player's jump.</span>
        </button>
        <button id="charReflectBtn" class="character-option">
            Reflect Character
            <span class="character-description">Reflects opponent's fireballs.</span>
        </button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const player1JumpBtn = document.getElementById('player1JumpBtn');
        const player1FireBtn = document.getElementById('player1FireBtn');
        const player2JumpBtn = document.getElementById('player2JumpBtn');
        const player2FireBtn = document.getElementById('player2FireBtn');
        const player2Controls = document.getElementById('player2-controls');

        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const restartButton = document.getElementById('restart-button');

        const menuScreen = document.getElementById('menu-screen');
        const onePlayerBtn = document.getElementById('onePlayerBtn');
        const twoPlayerBtn = document.getElementById('twoPlayerBtn');
        const gameContainer = document.getElementById('game-container');

        const characterSelectScreen = document.getElementById('character-select-screen');
        const characterSelectTitle = document.getElementById('character-select-title');
        const charStandardBtn = document.getElementById('charStandardBtn');
        const charBouncingBtn = document.getElementById('charBouncingBtn'); // Corrected typo
        const charCurvingBtn = document.getElementById('charCurvingBtn');
        const charReflectBtn = document.getElementById('charReflectBtn');


        // Game parameters - now dynamically calculated based on canvas size
        let GRAVITY;
        let JUMP_VELOCITY;
        let PLAYER_WIDTH;
        let PLAYER_HEIGHT;
        let PLAYER_SPEED;
        let FIREBALL_RADIUS;
        let FIREBALL_SPEED;
        let FIREBALL_DAMAGE;
        const MAX_HEALTH = 100;
        let FIREBALL_COOLDOWN_TIME; // Dynamic cooldown
        let FIREBALL_BOUNCE_VELOCITY; // Dynamic bounce velocity

        // Super Meter Parameters (also scaled)
        const MAX_SUPER_METER = 100;
        let SUPER_METER_GROWTH_RATE;
        let SUPER_FIREBALL_RADIUS;
        let SUPER_FIREBALL_DAMAGE;
        const SUPER_FIREBALL_COLOR = '#ff0';
        const SUPER_EFFECT_PULSE_SPEED = 0.005;
        const SUPER_EFFECT_MAX_ALPHA = 0.5;

        // Hit indicator parameters
        const HIT_EFFECT_DURATION = 200;
        const HIT_COLOR = '#ff0000';

        // Timer parameters
        const ROUND_TIME_LIMIT = 60;
        let currentRoundTime = ROUND_TIME_LIMIT;

        // Character Definitions - properties that are not sizes/speeds will remain constant
        const characters = {
            standard: {
                color: '#00ffff',
                fireballType: 'standard',
                fireballColor: '#ff8c00',
                fireballDamage: 10,
                fireballStrength: 10
            },
            bouncing: {
                color: '#ff00ff',
                fireballType: 'bouncing',
                fireballColor: '#00ff00',
                fireballDamage: 10,
                fireballStrength: 12
            },
            curving: {
                color: '#ff6600',
                fireballType: 'curving',
                fireballColor: '#00ccff',
                fireballDamage: 10,
                fireballStrength: 10,
                initialUpwardCurveDyFactor: -0.0005, // Factor to scale with canvas.height
                upwardCurveAccelerationFactor: -0.00009, // Factor to scale with canvas.height
                initialDownwardCurveDyFactor: 0.00004,
                downwardCurveAccelerationFactor: 0.00009
            },
            reflect: {
                color: '#800080',
                fireballType: 'reflect',
                fireballColor: '#800080',
                reflectSpeedMultiplier: 1.5,
                reflectSizeMultiplier: 1.5,
                reflectDamageMultiplier: 1.0,
                superReflectSpeedMultiplier: 0.5,
                superReflectSizeMultiplier: 2.5,
                superReflectDamageMultiplier: 1.5,
                superReflectFireballStrength: 50,
                shieldColor: 'rgba(255, 255, 255, 0.7)',
                shieldWidthFactor: 0.015, // Factor to scale with canvas.width
                shieldHeightFactor: 0.075, // Factor to scale with canvas.height
                shieldOffsetXFactor: 0.005, // Factor to scale with canvas.width
                shieldActiveDuration: 300,
                superMeterGainOnActivate: 5,
                superMeterDrainPerSecond: 10
            }
        };

        // Game state variables
        let gameState = 'menu';
        let gameRunning = false;
        let lastFrameTime = 0;
        const frameRate = 1000 / 60;
        let isTwoPlayerMode = false;

        // Player objects
        let player1 = {};
        let player2 = {};
        let fireballs = [];

        // Round system variables
        let player1RoundsWon = 0;
        let player2RoundsWon = 0;
        const ROUNDS_TO_WIN = 2;

        // Selected Characters
        let selectedCharacterTypeP1 = null;
        let selectedCharacterTypeP2 = null;

        // AI Progression Variables
        const aiOpponents = ['standard', 'bouncing', 'curving', 'reflect'];
        let currentOpponentIndex = 0;

        /**
         * Dynamically calculates game constants based on canvas size.
         * This ensures elements and physics scale correctly with the canvas.
         */
        function calculateDynamicConstants() {
            // Player dimensions
            PLAYER_WIDTH = canvas.width / 12; // Adjusted player width
            PLAYER_HEIGHT = canvas.height / 8; // Adjusted player height

            // Physics constants
            GRAVITY = canvas.height * 0.0008; // Gravity scales with canvas height
            JUMP_VELOCITY = -canvas.height * 0.025; // Jump strength scales with canvas height
            PLAYER_SPEED = canvas.width * 0.008; // Horizontal speed (if implemented)
            FIREBALL_SPEED = canvas.width * 0.015; // Fireball speed scales with canvas width
            FIREBALL_RADIUS = canvas.width * 0.015; // Fireball radius scales with canvas width
            FIREBALL_COOLDOWN_TIME = 2000; // Base cooldown (can be adjusted by game logic)
            FIREBALL_BOUNCE_VELOCITY = -canvas.height * 0.015; // Bouncing fireball upward velocity

            // Super meter related
            SUPER_METER_GROWTH_RATE = 0.2; // Base growth rate
            SUPER_FIREBALL_RADIUS = FIREBALL_RADIUS * 2; // Super fireball is 2x normal size
            SUPER_FIREBALL_DAMAGE = 25; // Fixed damage for super fireball (can be scaled too)
        }

        /**
         * Transitions the game state and updates screen visibility.
         * @param {string} newState - The new state to transition to.
         */
        function transitionToState(newState) {
            gameState = newState;
            menuScreen.style.display = 'none';
            characterSelectScreen.style.display = 'none';
            gameContainer.style.display = 'none';
            messageBox.style.display = 'none';

            if (isTwoPlayerMode) {
                player2Controls.style.display = 'flex';
            } else {
                player2Controls.style.display = 'none';
            }

            switch (newState) {
                case 'menu':
                    menuScreen.style.display = 'flex';
                    break;
                case 'charSelectP1':
                    characterSelectScreen.style.display = 'flex';
                    characterSelectTitle.textContent = "PLAYER 1: SELECT YOUR CHARACTER";
                    break;
                case 'charSelectP2':
                    characterSelectScreen.style.display = 'flex';
                    characterSelectTitle.textContent = "PLAYER 2: SELECT YOUR CHARACTER";
                    break;
                case 'playing':
                    gameContainer.style.display = 'flex';
                    break;
                case 'roundOver':
                case 'gameOver':
                case 'player1Win':
                    gameContainer.style.display = 'flex';
                    break;
            }
            render(performance.now());
        }

        /**
         * Initializes or resets the game state for a new game set (or campaign start for 1-player).
         */
        function initializeGame() {
            player1RoundsWon = 0;
            player2RoundsWon = 0;
            if (!isTwoPlayerMode) {
                currentOpponentIndex = 0;
                selectedCharacterTypeP2 = aiOpponents[currentOpponentIndex];
            }
            resetRound();
            restartButton.style.display = 'none';
            gameRunning = true;
            resizeCanvas(); // Ensure canvas and dynamic constants are updated
        }

        /**
         * Resets the game state for a new round (keeps round scores for current set).
         */
        function resetRound() {
            calculateDynamicConstants(); // Recalculate constants on round reset

            const p1Char = characters[selectedCharacterTypeP1];
            player1 = {
                x: canvas.width * 0.15,
                y: canvas.height - PLAYER_HEIGHT - (canvas.height * 0.02), // Adjusted ground padding
                width: PLAYER_WIDTH,
                height: PLAYER_HEIGHT,
                color: p1Char.color,
                dx: 0,
                dy: 0,
                onGround: false,
                health: MAX_HEALTH,
                isJumping: false,
                canShoot: (p1Char.fireballType !== 'reflect'),
                facing: 'right',
                lastFireballTime: 0,
                superMeter: 0,
                isSuperReady: false,
                fireballType: p1Char.fireballType,
                fireballColor: p1Char.fireballColor,
                fireballRadius: p1Char.fireballRadius || FIREBALL_RADIUS, // Use dynamic radius
                fireballDamage: p1Char.fireballDamage,
                fireballSpeed: p1Char.fireballSpeed || FIREBALL_SPEED, // Use dynamic speed
                fireballStrength: p1Char.fireballStrength || 10,
                reflectSpeedMultiplier: p1Char.reflectSpeedMultiplier || 1,
                reflectSizeMultiplier: p1Char.reflectSizeMultiplier || 1,
                reflectDamageMultiplier: p1Char.reflectDamageMultiplier || 1,
                superReflectSpeedMultiplier: p1Char.superReflectSpeedMultiplier || 1,
                superReflectSizeMultiplier: p1Char.superReflectSizeMultiplier || 1,
                superReflectDamageMultiplier: p1Char.superReflectDamageMultiplier || 1,
                superReflectFireballStrength: p1Char.superReflectFireballStrength || 50,
                reflectCooldownTime: p1Char.reflectCooldownTime || FIREBALL_COOLDOWN_TIME,
                shieldActive: false,
                shieldStartTime: 0,
                shieldCurrentAlpha: 0,
                shieldActiveDuration: p1Char.shieldActiveDuration || 0,
                superMeterGainOnActivate: p1Char.superMeterGainOnActivate || 0,
                superMeterDrainPerSecond: p1Char.superMeterDrainPerSecond || 0,
                lastHitTime: 0,
                superEffectActive: false,
                superEffectStartTime: 0,
                currentFireballCooldown: FIREBALL_COOLDOWN_TIME,
                currentSuperMeterGrowthRate: SUPER_METER_GROWTH_RATE
            };

            const p2Char = characters[selectedCharacterTypeP2];
            player2 = {
                x: canvas.width * 0.85 - PLAYER_WIDTH,
                y: canvas.height - PLAYER_HEIGHT - (canvas.height * 0.02), // Adjusted ground padding
                width: PLAYER_WIDTH,
                height: PLAYER_HEIGHT,
                color: p2Char.color,
                dx: 0,
                dy: 0,
                onGround: false,
                health: MAX_HEALTH,
                isJumping: false,
                canShoot: (p2Char.fireballType !== 'reflect'),
                facing: 'left',
                lastFireballTime: 0,
                superMeter: 0,
                isSuperReady: false,
                fireballType: p2Char.fireballType,
                fireballColor: p2Char.fireballColor,
                fireballRadius: p2Char.fireballRadius || FIREBALL_RADIUS,
                fireballDamage: p2Char.fireballDamage,
                fireballSpeed: p2Char.fireballSpeed || FIREBALL_SPEED,
                fireballStrength: p2Char.fireballStrength || 10,
                reflectSpeedMultiplier: p2Char.reflectSpeedMultiplier || 1,
                reflectSizeMultiplier: p2Char.reflectSizeMultiplier || 1,
                reflectDamageMultiplier: p2Char.reflectDamageMultiplier || 1,
                superReflectSpeedMultiplier: p2Char.superReflectSpeedMultiplier || 1,
                superReflectSizeMultiplier: p2Char.superReflectSizeMultiplier || 1,
                superReflectDamageMultiplier: p2Char.superReflectDamageMultiplier || 1,
                superReflectFireballStrength: p2Char.superReflectFireballStrength || 50,
                reflectCooldownTime: p2Char.reflectCooldownTime || FIREBALL_COOLDOWN_TIME,
                shieldActive: false,
                shieldStartTime: 0,
                shieldCurrentAlpha: 0,
                shieldActiveDuration: p2Char.shieldActiveDuration || 0,
                superMeterGainOnActivate: p2Char.superMeterGainOnActivate || 0,
                superMeterDrainPerSecond: p2Char.superMeterDrainPerSecond || 0,
                lastHitTime: 0,
                superEffectActive: false,
                superEffectStartTime: 0,
                currentFireballCooldown: FIREBALL_COOLDOWN_TIME,
                currentSuperMeterGrowthRate: SUPER_METER_GROWTH_RATE
            };

            currentRoundTime = ROUND_TIME_LIMIT;
            fireballs = [];
            gameRunning = true;
            messageBox.style.display = 'none';
            gameState = 'playing';
        }

        /**
         * Draws a player on the canvas.
         * @param {object} player - The player object to draw.
         */
        function drawPlayer(player, currentTime) {
            const defaultColor = characters[player.fireballType].color;
            let displayColor = defaultColor;
            if (currentTime - player.lastHitTime < HIT_EFFECT_DURATION) {
                displayColor = HIT_COLOR;
            }

            if (player.isSuperReady) {
                if (!player.superEffectActive) {
                    player.superEffectActive = true;
                    player.superEffectStartTime = currentTime;
                }
                const elapsed = currentTime - player.superEffectStartTime;
                const pulseAlpha = (Math.sin(elapsed * SUPER_EFFECT_PULSE_SPEED) * 0.5 + 0.5) * SUPER_EFFECT_MAX_ALPHA;

                ctx.save();
                ctx.globalAlpha = pulseAlpha;
                ctx.fillStyle = SUPER_FIREBALL_COLOR;
                ctx.beginPath();
                ctx.arc(player.x + player.width / 2, player.y + player.height / 2,
                        Math.max(player.width, player.height) * 1.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            } else {
                player.superEffectActive = false;
            }

            ctx.fillStyle = displayColor;
            ctx.fillRect(player.x, player.y, player.width, player.height);

            // Simple head/body indicator
            ctx.fillStyle = '#fff'; // White for head
            ctx.beginPath();
            ctx.arc(player.x + player.width / 2, player.y + player.height / 4, player.width / 4, 0, Math.PI * 2);
            ctx.fill();

            // Draw eye indicating direction
            ctx.fillStyle = '#000'; // Black for eye
            if (player.facing === 'right') {
                ctx.beginPath();
                ctx.arc(player.x + player.width * 0.7, player.y + player.height * 0.2, player.width * 0.06, 0, Math.PI * 2); // Eye size scaled
                ctx.fill();
            } else {
                ctx.beginPath();
                ctx.arc(player.x + player.width * 0.3, player.y + player.height * 0.2, player.width * 0.06, 0, Math.PI * 2); // Eye size scaled
                ctx.fill();
            }
        }

        /**
         * Draws a fireball on the canvas.
         * @param {object} fireball - The fireball object to draw.
         */
        function drawFireball(fireball) {
            ctx.fillStyle = fireball.color;
            ctx.beginPath();
            ctx.arc(fireball.x, fireball.y, fireball.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 10;
            ctx.shadowColor = fireball.color;
            ctx.fillStyle = fireball.color;
            ctx.beginPath();
            ctx.arc(fireball.x, fireball.y, fireball.radius * 0.8, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        /**
         * Draws the health bar for a player.
         * @param {object} player - The player object.
         * @param {number} x - X coordinate for the health bar.
         * @param {number} y - Y coordinate for the health bar.
         */
        function drawHealthBar(player, x, y) {
            const barWidth = canvas.width * 0.2; // 20% of canvas width
            const barHeight = canvas.height * 0.02; // 2% of canvas height
            const healthPercentage = player.health / MAX_HEALTH;
            const currentHealthWidth = barWidth * healthPercentage;

            ctx.fillStyle = '#555';
            ctx.fillRect(x, y, barWidth, barHeight);

            ctx.fillStyle = player.health > 50 ? '#28a745' : (player.health > 20 ? '#ffc107' : '#dc3545');
            ctx.fillRect(x, y, currentHealthWidth, barHeight);

            ctx.strokeStyle = '#eee';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, barWidth, barHeight);

            ctx.fillStyle = '#eee';
            ctx.font = `${canvas.height * 0.014}px "Press Start 2P"`; // Font size scales with height
            ctx.textAlign = 'center';
            ctx.fillText(`${player.health}`, x + barWidth / 2, y + barHeight / 2 + (canvas.height * 0.005));
        }

        /**
         * Draws the fireball cooldown bar for a player.
         * @param {object} player - The player object.
         * @param {number} x - X coordinate for the cooldown bar.
         * @param {number} y - Y Y coordinate for the cooldown bar.
         * @param {number} currentTime - The current time in milliseconds.
         */
        function drawCooldownBar(player, x, y, currentTime) {
            const barWidth = canvas.width * 0.2;
            const barHeight = canvas.height * 0.01;
            const timeElapsed = currentTime - player.lastFireballTime;
            const cooldownRemaining = Math.max(0, player.currentFireballCooldown - timeElapsed);
            const cooldownPercentage = 1 - (cooldownRemaining / player.currentFireballCooldown);

            ctx.fillStyle = '#555';
            ctx.fillRect(x, y, barWidth, barHeight);

            ctx.fillStyle = '#007bff';
            ctx.fillRect(x, y, barWidth * cooldownPercentage, barHeight);

            ctx.strokeStyle = '#eee';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, barWidth, barHeight);

            ctx.fillStyle = '#eee';
            ctx.font = `${canvas.height * 0.009}px "Press Start 2P"`; // Font size scales
            ctx.textAlign = 'center';
            ctx.fillText("FIREBALL", x + barWidth / 2, y + barHeight / 2 + (canvas.height * 0.003));
        }

        /**
         * Draws the super meter bar for a player.
         * @param {object} player - The player object.
         * @param {number} x - X coordinate for the super meter bar.
         * @param {number} y - Y coordinate for the super meter bar.
         */
        function drawSuperMeter(player, x, y) {
            const barWidth = canvas.width * 0.2;
            const barHeight = canvas.height * 0.01;
            const meterPercentage = player.superMeter / MAX_SUPER_METER;

            ctx.fillStyle = '#555';
            ctx.fillRect(x, y, barWidth, barHeight);

            ctx.fillStyle = player.isSuperReady ? SUPER_FIREBALL_COLOR : '#8a2be2';
            ctx.fillRect(x, y, barWidth * meterPercentage, barHeight);

            ctx.strokeStyle = '#eee';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, barWidth, barHeight);

            ctx.fillStyle = '#eee';
            ctx.font = `${canvas.height * 0.009}px "Press Start 2P"`; // Font size scales
            ctx.textAlign = 'center';
            ctx.fillText("SUPER", x + barWidth / 2, y + barHeight / 2 + (canvas.height * 0.003));
        }

        /**
         * Draws the round scores.
         */
        function drawRoundScores() {
            ctx.fillStyle = '#eee';
            ctx.font = `${canvas.height * 0.016}px "Press Start 2P"`; // Font size scales
            ctx.textAlign = 'left';
            ctx.fillText(`P1 Wins: ${player1RoundsWon}`, canvas.width * 0.02, canvas.height * 0.09); // Position relative to canvas

            if (isTwoPlayerMode) {
                ctx.textAlign = 'right';
                ctx.fillText(`P2 Wins: ${player2RoundsWon}`, canvas.width * 0.98, canvas.height * 0.09); // Position relative to canvas
            } else {
                ctx.textAlign = 'right';
                ctx.fillText(`AI: ${characters[selectedCharacterTypeP2].color.toUpperCase()}`, canvas.width * 0.98, canvas.height * 0.09);
            }
        }

        /**
         * Draws the reflect shield for a player.
         * @param {object} player - The player object with shield properties.
         */
        function drawShield(player) {
            if (player.fireballType === 'reflect' && player.shieldActive && player.shieldCurrentAlpha > 0) {
                ctx.save();
                ctx.globalAlpha = player.shieldCurrentAlpha;
                ctx.fillStyle = characters.reflect.shieldColor;

                const shieldWidth = canvas.width * characters.reflect.shieldWidthFactor;
                const shieldHeight = canvas.height * characters.reflect.shieldHeightFactor;
                const shieldOffsetX = canvas.width * characters.reflect.shieldOffsetXFactor;

                let shieldX = player.x;
                if (player.facing === 'right') {
                    shieldX = player.x + player.width - shieldOffsetX;
                } else {
                    shieldX = player.x - shieldWidth + shieldOffsetX;
                }
                const shieldY = player.y;

                ctx.fillRect(shieldX, shieldY, shieldWidth, shieldHeight);
                ctx.restore();
            }
        }

        /**
         * Draws the round timer bar in the top middle of the canvas.
         */
        function drawTimerBar() {
            const barTotalWidth = canvas.width * 0.6;
            const barHeight = canvas.height * 0.02;
            const barY = canvas.height * 0.02; // Position relative to canvas height

            const timePercentage = Math.max(0, currentRoundTime / ROUND_TIME_LIMIT);
            const currentBarWidth = barTotalWidth * timePercentage;

            const barX = (canvas.width - currentBarWidth) / 2;

            let barColor = '#28a745';
            if (currentRoundTime <= 30) {
                barColor = '#ffc107';
            }
            if (currentRoundTime <= 15) {
                barColor = '#dc3545';
            }

            ctx.fillStyle = '#555';
            ctx.fillRect((canvas.width - barTotalWidth) / 2, barY, barTotalWidth, barHeight);

            ctx.fillStyle = barColor;
            ctx.fillRect(barX, barY, currentBarWidth, barHeight);

            ctx.strokeStyle = '#eee';
            ctx.lineWidth = 2;
            ctx.strokeRect((canvas.width - barTotalWidth) / 2, barY, barTotalWidth, barHeight);

            ctx.fillStyle = '#eee';
            ctx.font = `${canvas.height * 0.014}px "Press Start 2P"`; // Font size scales
            ctx.textAlign = 'center';
            ctx.fillText(`${Math.ceil(currentRoundTime)}s`, canvas.width / 2, barY + barHeight / 2 + (canvas.height * 0.005));
        }


        /**
         * Checks for collision between two circles.
         * @param {object} circle1 - First circle object with x, y, radius.
         * @param {object} circle2 - Second circle object with x, y, radius.
         * @returns {boolean} True if circles are colliding, false otherwise.
         */
        function checkCircleCollision(circle1, circle2) {
            const dx = circle1.x - circle2.x;
            const dy = circle1.y - circle2.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            return distance < (circle1.radius + circle2.radius);
        }

        /**
         * Checks for collision between a circle and a rectangle.
         * @param {object} circle - Circle object with x, y, radius.
         * @param {object} rect - Rectangle object with x, y, width, height.
         * @returns {boolean} True if colliding, false otherwise.
         */
        function checkCircleRectCollision(circle, rect) {
            let testX = circle.x;
            let testY = circle.y;

            if (circle.x < rect.x) {
                testX = rect.x;
            } else if (circle.x > rect.x + rect.width) {
                testX = rect.x + rect.width;
            }

            if (circle.y < rect.y) {
                testY = rect.y;
            } else if (circle.y > rect.y + rect.height) {
                testY = rect.y + rect.height;
            }

            const distX = circle.x - testX;
            const distY = circle.y - testY;
            const distance = Math.sqrt((distX * distX) + (distY * distY));

            return distance <= circle.radius;
        }

        /**
         * Simple AI logic for player 2.
         * @param {object} aiPlayer - The AI controlled player (player2).
         * @param {object} opponentPlayer - The human player (player1).
         * @param {number} currentTime - The current time in milliseconds.
         */
        function simpleAI(aiPlayer, opponentPlayer, currentTime) {
            const AI_THINK_INTERVAL = 200;
            if (currentTime - (aiPlayer.lastAITime || 0) < AI_THINK_INTERVAL) {
                return;
            }
            aiPlayer.lastAITime = currentTime;

            const distanceX = Math.abs(aiPlayer.x - opponentPlayer.x);
            const distanceY = Math.abs(aiPlayer.y - opponentPlayer.y);

            if (aiPlayer.onGround && (opponentPlayer.y < aiPlayer.y - aiPlayer.height * 0.5 || Math.random() < 0.01)) {
                jump(aiPlayer);
            }

            const canPerformAction = (currentTime - aiPlayer.lastFireballTime >= aiPlayer.currentFireballCooldown);
            const isFireballApproaching = fireballs.some(fb =>
                fb.shooter !== aiPlayer &&
                Math.abs(fb.y - aiPlayer.y) < aiPlayer.height &&
                ((aiPlayer.facing === 'left' && fb.x < aiPlayer.x && fb.dx > 0) ||
                 (aiPlayer.facing === 'right' && fb.x > aiPlayer.x && fb.dx < 0)) &&
                Math.abs(fb.x - aiPlayer.x) < canvas.width * 0.4 // Within 40% of canvas width
            );

            if (aiPlayer.fireballType === 'reflect') {
                if (isFireballApproaching && canPerformAction) {
                    shootFireball(aiPlayer);
                } else if (canPerformAction && Math.random() < 0.05) {
                    shootFireball(aiPlayer);
                }
            } else {
                if (canPerformAction && distanceX < canvas.width * 0.7 && Math.random() < 0.3) {
                    shootFireball(aiPlayer);
                }
            }
        }

        /**
         * Updates the game state (positions, collisions, etc.).
         */
        function update() {
            if (!gameRunning) return;

            const currentTime = performance.now();
            const deltaTimeInSeconds = (currentTime - lastFrameTime) / 1000;

            currentRoundTime -= deltaTimeInSeconds;

            [player1, player2].forEach(player => {
                if (currentRoundTime <= 15) {
                    player.currentFireballCooldown = FIREBALL_COOLDOWN_TIME * 0.1;
                    player.currentSuperMeterGrowthRate = SUPER_METER_GROWTH_RATE * 25;
                } else if (currentRoundTime <= 30) {
                    player.currentFireballCooldown = FIREBALL_COOLDOWN_TIME * 0.5;
                    player.currentSuperMeterGrowthRate = SUPER_METER_GROWTH_RATE * 10;
                } else {
                    player.currentFireballCooldown = FIREBALL_COOLDOWN_TIME;
                    player.currentSuperMeterGrowthRate = SUPER_METER_GROWTH_RATE;
                }
            });

            if (currentRoundTime <= 0) {
                currentRoundTime = 0;
                gameRunning = false;

                let winnerMessage = "";
                if (player1.health > player2.health) {
                    player1RoundsWon++;
                    winnerMessage = "Player 1 Wins Round (Time Out)!";
                } else if (player2.health > player1.health) {
                    player2RoundsWon++;
                    winnerMessage = "Player 2 Wins Round (Time Out)!";
                } else {
                    winnerMessage = "Round Draw (Time Out)!";
                }

                if (isTwoPlayerMode) {
                    if (player1RoundsWon >= ROUNDS_TO_WIN) {
                        transitionToState('gameOver');
                        showMessage("Player 1 Wins the Game Set!", true);
                    } else if (player2RoundsWon >= ROUNDS_TO_WIN) {
                        transitionToState('gameOver');
                        showMessage("Player 2 Wins the Game Set!", true);
                    } else {
                        transitionToState('roundOver');
                        showMessage(winnerMessage);
                        setTimeout(resetRound, 2000);
                    }
                } else {
                    if (player1.health > player2.health) {
                        player1RoundsWon++;
                        if (player1RoundsWon >= ROUNDS_TO_WIN) {
                            currentOpponentIndex++;
                            player1RoundsWon = 0;
                            player2RoundsWon = 0;
                            if (currentOpponentIndex < aiOpponents.length) {
                                selectedCharacterTypeP2 = aiOpponents[currentOpponentIndex];
                                transitionToState('roundOver');
                                showMessage(`You defeated ${selectedCharacterTypeP2.toUpperCase()}! Next opponent!`);
                                setTimeout(resetRound, 2000);
                            } else {
                                transitionToState('player1Win');
                                showMessage("CONGRATULATIONS! YOU WIN THE CAMPAIGN!", true);
                            }
                        } else {
                            transitionToState('roundOver');
                            showMessage("You won the round (Time Out)!");
                            setTimeout(resetRound, 2000);
                        }
                    } else {
                        player2RoundsWon++;
                        transitionToState('gameOver');
                        showMessage("GAME OVER! Time Out!", true);
                    }
                }
                return;
            }

            // Ground Y position relative to canvas height
            const groundY = canvas.height - (canvas.height * 0.02); // 2% from bottom

            player1.dy += GRAVITY;
            player1.y += player1.dy;
            if (player1.y + player1.height > groundY) {
                player1.y = groundY - player1.height;
                player1.dy = 0;
                player1.onGround = true;
                player1.isJumping = false;
            } else {
                player1.onGround = false;
            }

            player2.dy += GRAVITY;
            player2.y += player2.dy;
            if (player2.y + player2.height > groundY) {
                player2.y = groundY - player2.height;
                player2.dy = 0;
                player2.onGround = true;
                player2.isJumping = false;
            } else {
                player2.onGround = false;
            }

            if (!isTwoPlayerMode) {
                simpleAI(player2, player1, currentTime);
            }

            [player1, player2].forEach(player => {
                if (player.fireballType === 'reflect' && player.shieldActive) {
                    const elapsed = currentTime - player.shieldStartTime;
                    if (elapsed >= player.shieldActiveDuration) {
                        player.shieldActive = false;
                        player.shieldCurrentAlpha = 0;
                    } else {
                        player.shieldCurrentAlpha = 1 - (elapsed / player.shieldActiveDuration);
                        player.superMeter -= player.superMeterDrainPerSecond * deltaTimeInSeconds;
                        player.superMeter = Math.max(0, player.superMeter);
                        if (player.superMeter <= 0) {
                            player.shieldActive = false;
                            player.shieldCurrentAlpha = 0;
                        }
                    }
                }
            });

            [player1, player2].forEach(player => {
                if (!(player.fireballType === 'reflect' && player.shieldActive)) {
                    player.superMeter += player.currentSuperMeterGrowthRate;
                    player.superMeter = Math.min(player.superMeter, MAX_SUPER_METER);
                }
                player.isSuperReady = (player.superMeter >= MAX_SUPER_METER);
            });

            const fireballsToRemove = new Set();

            fireballs.forEach((fireball, index) => {
                fireball.x += fireball.dx;

                if (fireball.fireballType === 'bouncing') {
                    fireball.dy += GRAVITY;
                    fireball.y += fireball.dy;

                    if (fireball.y + fireball.radius > groundY) {
                        fireball.y = groundY - fireball.radius;
                        fireball.dy = FIREBALL_BOUNCE_VELOCITY;
                    }
                    if (fireball.y - fireball.radius < 0) {
                        fireball.y = fireball.radius;
                        fireball.dy = -FIREBALL_BOUNCE_VELOCITY;
                    }
                } else if (fireball.fireballType === 'curving') {
                    fireball.dy += fireball.curveAcceleration;
                    fireball.y += fireball.dy;

                    if (fireball.y + fireball.radius < 0 || fireball.y - fireball.radius > canvas.height) {
                        fireballsToRemove.add(index);
                    }
                }

                let targetPlayer = null;
                if (fireball.shooter === player1) {
                    targetPlayer = player2;
                } else if (fireball.shooter === player2) {
                    targetPlayer = player1;
                }

                if (targetPlayer) {
                    if (targetPlayer.fireballType === 'reflect' && fireball.shooter !== targetPlayer && targetPlayer.shieldActive) {
                        const shieldWidth = canvas.width * characters.reflect.shieldWidthFactor;
                        const shieldHeight = canvas.height * characters.reflect.shieldHeightFactor;
                        const shieldOffsetX = canvas.width * characters.reflect.shieldOffsetXFactor;

                        let shieldX = targetPlayer.x;
                        if (targetPlayer.facing === 'right') {
                            shieldX = targetPlayer.x + targetPlayer.width - shieldOffsetX;
                        } else {
                            shieldX = targetPlayer.x - shieldWidth + shieldOffsetX;
                        }
                        const shieldY = targetPlayer.y;
                        const shieldRect = { x: shieldX, y: shieldY, width: shieldWidth, height: shieldHeight };

                        if (checkCircleRectCollision(fireball, shieldRect)) {
                            let speedMult = targetPlayer.reflectSpeedMultiplier;
                            let sizeMult = targetPlayer.reflectSizeMultiplier;
                            let damageMult = targetPlayer.reflectDamageMultiplier;
                            let newStrength = fireball.strength * 1.2;

                            if (targetPlayer.isSuperReady) {
                                speedMult = targetPlayer.superReflectSpeedMultiplier;
                                sizeMult = targetPlayer.superReflectSizeMultiplier;
                                damageMult = targetPlayer.superReflectDamageMultiplier;
                                newStrength = targetPlayer.superReflectFireballStrength;
                                targetPlayer.superMeter = 0;
                                targetPlayer.isSuperReady = false;
                            }

                            fireball.dx *= -speedMult;
                            fireball.radius *= sizeMult;
                            fireball.damage *= damageMult;
                            fireball.shooter = targetPlayer;
                            fireball.color = targetPlayer.fireballColor;
                            fireball.fireballType = 'standard';
                            fireball.dy = 0;
                            fireball.strength = newStrength;

                            targetPlayer.superMeter = Math.min(MAX_SUPER_METER, targetPlayer.superMeter + 20);

                            targetPlayer.shieldActive = false;
                            targetPlayer.shieldCurrentAlpha = 0;
                            return;
                        }
                    }

                    if (fireball.x < targetPlayer.x + targetPlayer.width &&
                        fireball.x + fireball.radius > targetPlayer.x &&
                        fireball.y < targetPlayer.y + targetPlayer.height &&
                        fireball.y + fireball.radius > targetPlayer.y
                    ) {
                        targetPlayer.health -= fireball.damage;
                        targetPlayer.lastHitTime = currentTime;
                        if (targetPlayer.health < 0) targetPlayer.health = 0;
                        fireballsToRemove.add(index);
                    }
                }

                if ((fireball.x + fireball.radius < 0 || fireball.x - fireball.radius > canvas.width)) {
                    fireballsToRemove.add(index);
                }
            });

            for (let i = 0; i < fireballs.length; i++) {
                for (let j = i + 1; j < fireballs.length; j++) {
                    const fb1 = fireballs[i];
                    const fb2 = fireballs[j];

                    if (fb1.shooter !== fb2.shooter) {
                        if (checkCircleCollision(fb1, fb2)) {
                            if (fb1.strength > fb2.strength) {
                                fireballsToRemove.add(j);
                                fb1.strength -= fb2.strength;
                            } else if (fb2.strength > fb1.strength) {
                                fireballsToRemove.add(i);
                                fb2.strength -= fb1.strength;
                            } else {
                                fireballsToRemove.add(i);
                                fireballsToRemove.add(j);
                            }
                        }
                    }
                }
            }

            fireballs = fireballs.filter((_, index) => !fireballsToRemove.has(index));

            if (player1.health <= 0) {
                gameRunning = false;
                player2RoundsWon++;

                if (isTwoPlayerMode) {
                    if (player2RoundsWon >= ROUNDS_TO_WIN) {
                        transitionToState('gameOver');
                        showMessage("Player 2 Wins the Game Set!", true);
                    } else {
                        transitionToState('roundOver');
                        showMessage("Player 2 Wins Round!");
                        setTimeout(resetRound, 2000);
                    }
                } else {
                    transitionToState('gameOver');
                    showMessage("GAME OVER! You were defeated!", true);
                }
            } else if (player2.health <= 0) {
                gameRunning = false;
                player1RoundsWon++;

                if (isTwoPlayerMode) {
                    if (player1RoundsWon >= ROUNDS_TO_WIN) {
                        transitionToState('gameOver');
                        showMessage("Player 1 Wins the Game Set!", true);
                    } else {
                        transitionToState('roundOver');
                        showMessage("Player 1 Wins Round!");
                        setTimeout(resetRound, 2000);
                    }
                } else {
                    if (player1RoundsWon >= ROUNDS_TO_WIN) {
                        currentOpponentIndex++;
                        player1RoundsWon = 0;
                        player2RoundsWon = 0;

                        if (currentOpponentIndex < aiOpponents.length) {
                            selectedCharacterTypeP2 = aiOpponents[currentOpponentIndex];
                            transitionToState('roundOver');
                            showMessage(`You defeated ${selectedCharacterTypeP2.toUpperCase()}! Next opponent!`);
                            setTimeout(resetRound, 2000);
                        } else {
                            transitionToState('player1Win');
                            showMessage("CONGRATULATIONS! YOU WIN THE CAMPAIGN!", true);
                        }
                    } else {
                        transitionToState('roundOver');
                        showMessage("You won the round!");
                        setTimeout(resetRound, 2000);
                    }
                }
            }
        }

        /**
         * Renders all game elements on the canvas.
         */
        function render(currentTime) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameState === 'playing' || gameState === 'roundOver' || gameState === 'gameOver' || gameState === 'player1Win') {
                // Draw ground
                ctx.fillStyle = '#663300';
                ctx.fillRect(0, canvas.height - (canvas.height * 0.02), canvas.width, canvas.height * 0.02); // Ground height scales

                drawPlayer(player1, currentTime);
                drawPlayer(player2, currentTime);

                fireballs.forEach(drawFireball);

                // Bar positions now relative to canvas size
                const barX1 = canvas.width * 0.02; // 2% from left
                const barX2 = canvas.width * 0.98 - (canvas.width * 0.2); // 2% from right, accounting for bar width
                const barYHealth = canvas.height * 0.02; // 2% from top
                const barYCooldown = barYHealth + (canvas.height * 0.02) + (canvas.height * 0.005); // Below health bar + small gap
                const barYSuper = barYCooldown + (canvas.height * 0.01) + (canvas.height * 0.005); // Below cooldown bar + small gap

                drawHealthBar(player1, barX1, barYHealth);
                drawHealthBar(player2, barX2, barYHealth);

                drawCooldownBar(player1, barX1, barYCooldown, currentTime);
                drawCooldownBar(player2, barX2, barYCooldown, currentTime);

                drawSuperMeter(player1, barX1, barYSuper);
                drawSuperMeter(player2, barX2, barYSuper);

                drawRoundScores();
                drawTimerBar();

                drawShield(player1);
                drawShield(player2);
            }
        }

        /**
         * The main game loop.
         */
        function gameLoop(currentTime) {
            requestAnimationFrame(gameLoop);

            if (gameState === 'playing') {
                const deltaTime = currentTime - lastFrameTime;
                if (deltaTime >= frameRate) {
                    update();
                    lastFrameTime = currentTime;
                }
            }
            render(currentTime);
        }

        /**
         * Player jumps.
         * @param {object} player - The player object that is jumping.
         */
        function jump(player) {
            if (player.onGround) {
                player.dy = JUMP_VELOCITY;
                player.onGround = false;
                player.isJumping = true;
            }
        }

        /**
         * Player shoots a fireball or activates reflect.
         * @param {object} shooter - The player object.
         */
        function shootFireball(shooter) {
            const currentTime = performance.now();

            if (shooter.fireballType === 'reflect') {
                if (shooter.isSuperReady) {
                    fireballs.push({
                        x: shooter.facing === 'right' ? shooter.x + shooter.width : shooter.x,
                        y: shooter.y + shooter.height / 2,
                        radius: SUPER_FIREBALL_RADIUS * 1.5,
                        color: SUPER_FIREBALL_COLOR,
                        dx: shooter.facing === 'right' ? FIREBALL_SPEED * 0.5 : -FIREBALL_SPEED * 0.5,
                        dy: 0,
                        shooter: shooter,
                        damage: SUPER_FIREBALL_DAMAGE * 1.5,
                        isSuper: true,
                        fireballType: 'standard',
                        strength: characters.reflect.superReflectFireballStrength
                    });
                    shooter.superMeter = 0;
                    shooter.isSuperReady = false;
                    shooter.lastFireballTime = currentTime;
                } else {
                    if (currentTime - shooter.lastFireballTime < shooter.reflectCooldownTime) {
                        return;
                    }
                    shooter.lastFireballTime = currentTime;
                    shooter.shieldActive = true;
                    shooter.shieldStartTime = currentTime;
                    shooter.shieldCurrentAlpha = 1;
                    shooter.superMeter = Math.min(MAX_SUPER_METER, shooter.superMeter + (shooter.superMeterGainOnActivate || 0));
                }
                return;
            }

            let initialDy = 0;
            let curveAcc = 0;
            if (shooter.fireballType === 'curving') {
                const curvingCharProps = characters.curving;
                if (shooter.onGround) {
                    initialDy = canvas.height * curvingCharProps.initialUpwardCurveDyFactor;
                    curveAcc = canvas.height * curvingCharProps.upwardCurveAccelerationFactor;
                } else {
                    initialDy = canvas.height * curvingCharProps.initialDownwardCurveDyFactor;
                    curveAcc = canvas.height * curvingCharProps.downwardCurveAccelerationFactor;
                }
            }

            if (shooter.isSuperReady) {
                fireballs.push({
                    x: shooter.facing === 'right' ? shooter.x + shooter.width : shooter.x,
                    y: shooter.y + shooter.height / 2,
                    radius: SUPER_FIREBALL_RADIUS,
                    color: SUPER_FIREBALL_COLOR,
                    dx: shooter.facing === 'right' ? shooter.fireballSpeed * 1.2 : -shooter.fireballSpeed * 1.2,
                    dy: (shooter.fireballType === 'bouncing') ? FIREBALL_BOUNCE_VELOCITY : initialDy,
                    shooter: shooter,
                    damage: SUPER_FIREBALL_DAMAGE,
                    isSuper: true,
                    fireballType: shooter.fireballType,
                    bounceFactor: characters[shooter.fireballType].bounceFactor,
                    curveAcceleration: curveAcc,
                    strength: MAX_SUPER_METER
                });
                shooter.superMeter = 0;
                shooter.isSuperReady = false;
            } else {
                if (currentTime - shooter.lastFireballTime < shooter.currentFireballCooldown) {
                    return;
                }

                fireballs.push({
                    x: shooter.facing === 'right' ? shooter.x + shooter.width : shooter.x,
                    y: shooter.y + shooter.height / 2,
                    radius: shooter.fireballRadius,
                    color: shooter.fireballColor,
                    dx: shooter.facing === 'right' ? shooter.fireballSpeed : -shooter.fireballSpeed,
                    dy: (shooter.fireballType === 'bouncing') ? FIREBALL_BOUNCE_VELOCITY : initialDy,
                    shooter: shooter,
                    damage: shooter.fireballDamage,
                    isSuper: false,
                    fireballType: shooter.fireballType,
                    bounceFactor: characters[shooter.fireballType].bounceFactor,
                    curveAcceleration: curveAcc,
                    strength: shooter.fireballStrength
                });
            }
            shooter.lastFireballTime = currentTime;
            if (shooter.fireballType !== 'reflect') {
                shooter.superMeter = 0;
            }
        }

        /**
         * Displays a message box with game status (e.g., winner).
         * @param {string} message - The message to display.
         * @param {boolean} showRestartBtn - Whether to show the restart button.
         */
        function showMessage(message, showRestartBtn = false) {
            messageText.textContent = message;
            messageBox.style.display = 'flex';
            if (showRestartBtn) {
                restartButton.style.display = 'block';
            } else {
                restartButton.style.display = 'none';
            }
        }

        /**
         * Event listener for keyboard input.
         */
        document.addEventListener('keydown', (e) => {
            if (gameState !== 'playing') return;

            switch (e.key) {
                case 'a':
                case 'A':
                    jump(player1);
                    break;
                case 's':
                case 'S':
                    shootFireball(player1);
                    break;
                case 'k':
                case 'K':
                    if (isTwoPlayerMode) jump(player2);
                    break;
                case 'l':
                case 'L':
                    if (isTwoPlayerMode) shootFireball(player2);
                    break;
            }
        });

        // Event listeners for button clicks
        player1JumpBtn.addEventListener('click', () => {
            if (gameState === 'playing') jump(player1);
        });
        player1FireBtn.addEventListener('click', () => {
            if (gameState === 'playing') shootFireball(player1);
        });
        player2JumpBtn.addEventListener('click', () => {
            if (gameState === 'playing' && isTwoPlayerMode) jump(player2);
        });
        player2FireBtn.addEventListener('click', () => {
            if (gameState === 'playing' && isTwoPlayerMode) shootFireball(player2);
        });

        // Restart button functionality
        restartButton.addEventListener('click', () => {
            transitionToState('menu');
            gameRunning = false;
            selectedCharacterTypeP1 = null;
            selectedCharacterTypeP2 = null;
            currentOpponentIndex = 0;
            player1RoundsWon = 0;
            player2RoundsWon = 0;
        });

        // Menu button listeners
        onePlayerBtn.addEventListener('click', () => {
            isTwoPlayerMode = false;
            transitionToState('charSelectP1');
        });

        twoPlayerBtn.addEventListener('click', () => {
            isTwoPlayerMode = true;
            transitionToState('charSelectP1');
        });

        // Character Selection button listeners
        charStandardBtn.addEventListener('click', () => {
            if (gameState === 'charSelectP1') {
                selectedCharacterTypeP1 = 'standard';
                if (isTwoPlayerMode) {
                    transitionToState('charSelectP2');
                } else {
                    initializeGame();
                    transitionToState('playing');
                }
            } else if (gameState === 'charSelectP2') {
                selectedCharacterTypeP2 = 'standard';
                initializeGame();
                transitionToState('playing');
            }
        });

        charBouncingBtn.addEventListener('click', () => {
            if (gameState === 'charSelectP1') {
                selectedCharacterTypeP1 = 'bouncing';
                if (isTwoPlayerMode) {
                    transitionToState('charSelectP2');
                } else {
                    initializeGame();
                    transitionToState('playing');
                }
            } else if (gameState === 'charSelectP2') {
                selectedCharacterTypeP2 = 'bouncing';
                initializeGame();
                transitionToState('playing');
            }
        });

        charCurvingBtn.addEventListener('click', () => {
            if (gameState === 'charSelectP1') {
                selectedCharacterTypeP1 = 'curving';
                if (isTwoPlayerMode) {
                    transitionToState('charSelectP2');
                } else {
                    initializeGame();
                    transitionToState('playing');
                }
            } else if (gameState === 'charSelectP2') {
                selectedCharacterTypeP2 = 'curving';
                initializeGame();
                transitionToState('playing');
            }
        });

        charReflectBtn.addEventListener('click', () => {
            if (gameState === 'charSelectP1') {
                selectedCharacterTypeP1 = 'reflect';
                if (isTwoPlayerMode) {
                    transitionToState('charSelectP2');
                } else {
                    initializeGame();
                    transitionToState('playing');
                }
            } else if (gameState === 'charSelectP2') {
                selectedCharacterTypeP2 = 'reflect';
                initializeGame();
                transitionToState('playing');
            }
        });


        // Handle canvas resizing for responsiveness
        function resizeCanvas() {
            const gameContainer = document.getElementById('game-container');
            let containerWidth;

            const wasHidden = gameContainer.style.display === 'none';
            if (wasHidden) {
                gameContainer.style.display = 'flex';
            }

            containerWidth = gameContainer.clientWidth - (parseInt(getComputedStyle(gameContainer).paddingLeft) * 2);

            if (wasHidden) {
                gameContainer.style.display = 'none';
            }

            const aspectRatio = 3 / 4;
            canvas.width = Math.min(containerWidth, 800); // Max width of 800px for canvas
            canvas.height = canvas.width / aspectRatio;

            // Recalculate dynamic constants after canvas resize
            calculateDynamicConstants();

            if (gameRunning || gameState === 'playing' || gameState === 'roundOver' || gameState === 'gameOver' || gameState === 'player1Win') {
                if (gameState !== 'gameOver' && gameState !== 'player1Win') {
                    resetRound();
                } else {
                    render(performance.now());
                }
            }
            render(performance.now());
        }

        // Listen for window resize events
        window.addEventListener('resize', resizeCanvas);

        // Prevent zooming on double-tap for mobile devices
        document.addEventListener('touchstart', function(event) {
            if (event.touches.length > 1) {
                event.preventDefault();
            }
        }, { passive: false });

        // Initial setup
        window.onload = function() {
            transitionToState('menu');
            requestAnimationFrame(gameLoop);
        };
    </script>
</body>
</html>
